<a id="top"></a> 

### [⬅️ README][readme]
## [Глава 3. Арифметические типы](#top)
Проекты выполнены в операционной системе Ubuntu (поверх WSL 2).


По книге **Роберт С. Сикорд - Эффективный С. Профессиональное программирование**.


---
<a id="content"></a> 

### [Содержание](#top)
- ### [Целые числа](#section_01)
- ### [Числа с плавающей запятой](#section_02)
- ### [Арифметическое преобразование](#section_03) 


---
<a id="section_01"></a> 

## [Целые числа](#top)
***Значение*** целочисленного объекта является обычным математическим числом и ***представлено*** в виде битов в выделенной для объекта памяти, которые кодируют это значение.


Все целочисленные типы, кроме char, signed char и unsigned char, могут 
содержать неиспользуемые биты, которые называются ***заполнением***.


***Заполенения*** позволяют: 
- реализации обходить причуды аппаратной платформы (*такие как пропуск бита со знаком посреди представления из нескольких машинных слов*);
- оптимально поддерживать целевую архитектуру. 


***Ширина числа*** - это количество битов, используемых для представления значения заданного типа, не считая заполнения, но включая знак (зачастую обозначается как `N`).


***Точность*** — это количество битов, используемых для представления значения, не считая знака и заполнения.


***Заголовочный файл `<limits.h>` предоставляет минимальные и максимальные допустимые значения*** для различных целочисленных типов. 


***Допустимое значение*** - это такое, которое можно представить с помощью того количества битов, которое доступно объекту конкретного типа. 


❗***Компилятор, встречая значение, которое нельзя представить, может либо выдать диагностическое сообщение, либо преобразовать значение в представимое (хоть и некорректное).***


***Стандарт C предъявляет к размерам целых чисел 3 требования:*** 
1. область хранения любого типа данных должна иметь объем, кратный размеру объекта `unsigned char` (возможно, включая заполнение); 
2. каждый целочисленный тип должен поддерживать минимальный переносимый диапазон значений, на который можно положиться в любой реализации. 
3. меньший тип неможет быть шире большего. Поэтому 
`USHRT_MAX`, к примеру, не может быть больше `UINT_MAX`, хотя типы `unsinged short` и `unsinged int` могут иметь одинаковую ширину.


### Беззнаковые числа. Циклический перенос
***Циклический перенос (wraparound)*** происходит при выполнении арифметической операции, результат которой слишком маленький (меньше `0`) или большой (больше `2N – 1`), чтобы его можно было представить в виде 
конкретного беззнакового целочисленного типа. В этом случае берется остаток от деления значения на `N`, которое на единицу больше максимально допустимого значения итогового типа. 


❗***В языке C циклический перенос является определенным поведением.*** 


Код ниже присваивает переменной `ui` максимально 
допустимое значение и затем инкрементирует ее. Полученный результат нельзя представить как `unsigned int`, поэтому он циклически переносится 
и превращается в `0`. Если это значение декрементировать, то оно снова выйдет за рамки допустимого диапазона и в результате циклического переноса превратится в `UINT_MAX`.


```c
unsigned int ui = UINT_MAX; // 4,294,967,295 в x86

ui++;
printf("ui = %u\n", ui); // ui равно 0

ui--;
printf("ui = %u\n", ui); // ui равно 4,294,967,295
```


Ввиду циклического переноса ***беззнаковое целочисленное выражение никогда не может быть меньше `0`***. 


Например, переменная `i` в следующем цикле `for` не может иметь отрицательного значения, поэтому данный цикл никогда не прервется:


```c
for (unsigned int i = n; i >= 0; --i)
```


Чтобы избежать незапланированного поведения, необходимо удостовериться в отсутствии циклического переноса с учетом лимитов, указанных в заголовочном файле `<limits.h>`. 


Нужно быть осторожным при реализации этих проверок, поскольку в них легко ошибиться. Например, следующий код содержит дефект, так как `sum + ui` никогда не может быть больше, чем `UINT_MAX`:


```c
extern unsigned int ui, sum;

// присваиваем значения переменным ui и sum
if (sum + ui > UINT_MAX) {
    too_big();
}
else {
    sum = sum + ui;
}
```


Если результат `sum + ui` больше `UINT_MAX`, то приводится по модулю к `UINT_MAX + 1`. Таким образом вся эта проверка оказывается бесполезной и сгенерированный код всегда будет выполнять сложение. 


Чтобы исправить положение, можно вычесть `sum`
из обеих сторон неравенства с целью создать следующую эффективную проверку:


```c
extern unsigned int ui, sum;

// присваиваем значения переменным ui и sum
if (ui > UINT_MAX - sum){
    too_big();
}
else {
    sum = sum + ui;
}
```


Значение `UINT_MAX` — самое большое, какое может быть представлено как `unsigned int`, а `sum` находится где-то между `0` и `UINT_MAX`: 
- если `sum` равно `UINT_MAX`, то разность будет равна `0`; 
- если `sum` равно `0`, то результат будет равен `UINT_MAX`. 


Поскольку значение, возвращаемое этой операцией, всегда находится в допустимом диапазоне (от `0` до `UINT_MAX`), с ним не может произойти ***циклический перенос***.


Та же проблема возникает при сравнении результата арифметической операции (`j`) с `0` (минимальным беззнаковым значением):


```c
extern unsigned int i, j;
// присваиваем значения переменным i и j
if (i - j < 0) {// это невозможно
    negative();
}
else {
    i = i - j;
}
```


Поскольку беззнаковые целочисленные значения никогда не могут быть отрицательными, вычитание будет выполняться в любом случае. Вместо этого можно сравнить `j` с `i`, чтобы узнать происходит ли циклический перенос:


```c
if (j > i) {// правильно
    negative();
}
else {
    i = i - j;
}
```


Если `j > i`, то мы можем с уверенностью сказать, что результат будет циклически перенесен. Убрав из проверки операцию вычитания, исключается возможность возникновения циклического переноса во время ее выполнения.


❗***ВНИМАНИЕ: ширина***, используемая при переносе, зависит от реализации. Это значит, что на разных платформах можно получить различные результаты. Если этого не учитывать, то код не будет переносимым!


### Знаковые целые
***Целочисленные типы со знаком*** имеют более сложное представление, чем их беззнаковые аналоги. Язык C традиционно поддерживает 3 варианта представления таких значений:
1. ***прямой код*** — старший разряд обозначает знак, а остальные разряды представляют величину значения в обычной двоичной системе;
2. ***обратный код*** — разряду со знаком назначается ***вес*** ${–(2^{N – 1} – 1)}$, а остальные разряды значения имеют те же веса, что и в беззнаковом типе;
3. ***дополнительный код*** — разряду со знаком назначается ***вес*** ${–(2^{N – 1})}$, а остальные разряды значения имеют теже веса, что ив беззнаковом типе.


❗***Нельзя выбрать конкретное представление:*** оно определяется теми, кто реализует ***язык C*** для различных систем. В употреблении находятся все три варианта, но последний намного популярнее — настолько, что *комитет во главе стандарта C собирается оставить в спецификации C2x лишь дополнительный код.* 


#### Предствление знакового числа через дополнительный код
***Целочисленные типы со знаком и шириной `N`*** способны представить любое целое значение в диапазоне от ${–2^{N – 1}}$ до ${2^{N – 1} – 1}$. Это означает, что восьмибитное значение типа `signed char` имеет диапазон 
от ${–128}$ до ${127}$. 


***Дополнительный код*** может также представить еще одно самое маленькое отрицательное значение. Для восьмибитного типа `signed char` это ${–128}$, и его модуль, ${|–128|}$, не может быть представлен данным типом. Подобное положение приводит к возникновению ряда 
интересных граничных ситуаций, которые будут рассмотрены ддальше.


В следующей таблице перечислены константные выражения из заголовочного файла `<limits.h>` для каждого типа со знаком, минимальный диапазон, который требуется согласно стандарту, и фактический диапазон в современных реализациях ***x86***.


***Диапазоны целых чисел со знаком***
| Константное выражение | Минимальные величины                          | Значение в x86    | Тип           |
|-----------------------|-----------------------------------------------|-------------------|---------------|
| `SCHAR_MIN`           | –127 //${–(2^{7–1})}$                         | ${-2^{7–1}-1}$    | `signed char` |
| `SCHAR_MAX`           | +127 //${2^{7–1}}$                            | ${2^{7–1}}$       | `signed char` |
| `SHRT_MIN`            | –32 767 //${–(2^{15–1})}$                     | ${-2^{15–1}-1}$   | `short`       |
| `SHRT_MAX`            | +32 767 //${2^{15–1}}$                        | ${2^{15–1}}$      | `short`       |
| `INT_MIN`             | –32 767 //${–(2^{15–1})}$                     | ${–(2^{15–1})-1}$ | `int`         |
| `INT_MAX`             | +32 767 //${2^{15–1}}$                        | ${2^{15–1}} $     | `int`         |
| `LONG_MIN`            | –2 147 483 647 //${–(2^{31–1})}$              | ${–(2^{31–1})-1}$ | `long`        |
| `LONG_MAX`            | +2 147 483 647 //${2^{31–1}}$                 | ${2^{31–1}-1}$    | `long`        |
| `LLONG_MIN`           | –9 223 372 036 854 775 807 //${–(2^{63–1})}$  | ${–(2^{63–1})-1}$ | `long long`   |
| `LLONG_MAX`           | +9 223 372 036 854 775 807 //${2^{63–1}}$     | ${2^{63–1}-1}$    | `long long`   |


***Представление отрицательных чисел в дополнительном коде*** состоит из разрядов для хранения знака и самого значения. Разряду со знаком назначается вес ${–(2^{N – 1})}$. Чтобы сделать значение отрицательным в дополнительном коде, достаточно инвертировать каждый значащий бит 
и затем прибавить 1 (с переносом, если это необходимо).


В следующей таблице показаны двоичные и десятичные представления для 8-битного целочисленного типа со знаком в дополнительном коде без заполнения (то есть ${N=8}$). 

***Значения в прямом и дополнительном кодах ${(N=8)}$***
| Двоичное (прямой код) | Двоичное (доп. код)   | Десятичное (unsigned) | Десятичное (signed)   | Вес (доп. код)                | Константа     |
|-----------------------|-----------------------|-----------------------|-----------------------|-------------------------------|---------------|
| 00000000              | 00000000              | 0                     | 0                     | ${0}$                         |               |
| 00000001              | 00000001              | 1                     | 1                     | ${2^0}$                       |               |
| 01111110              | 01111110              | 126                   | 126                   | ${2^6+2^5+2^4+2^3+2^2+2^1}$   |               |
| 01111111              | 01111111              | 127                   | 127                   | ${2^{N−1}−1}$                 | `SCHAR_MAX`   |
| 10000000              | 10000000              | 128                   | –128                  | ${−(2^{N−1})+0}$              | `SCHAR_MIN`   |
| 10000001              | 10000001              | 129                   | –127                  | ${−(2^{N–1})+1}$              |               |
| 11111110              | 11111110              | 255                   | −2                    | ${−(2^{N–1})+126}$            |               |
| 11111111              | 11111111              | 256                   | −1                    | ${−(2^{N–1})+127}$            |               |







---
<a id="section_02"></a> 

## [](#top)


---
<a id="section_03"></a> 

## [](#top)



---
[readme]: ../README.md