<a id="top"></a> 

### [⬅️ README][readme]
## [Глава 3. Арифметические типы](#top)
Проекты выполнены в операционной системе Ubuntu (поверх WSL 2).


По книге **Роберт С. Сикорд - Эффективный С. Профессиональное программирование**.


---
<a id="content"></a> 

### [Содержание](#top)
- ### [Целые числа](#section_01)
- ### [Числа с плавающей запятой](#section_02)
- ### [Арифметическое преобразование](#section_03) 


---
<a id="section_01"></a> 

## [Целые числа](#top)
***Значение*** целочисленного объекта является обычным математическим числом и ***представлено*** в виде битов в выделенной для объекта памяти, которые кодируют это значение.


Все целочисленные типы, кроме char, signed char и unsigned char, могут 
содержать неиспользуемые биты, которые называются ***заполнением***.


***Заполенения*** позволяют: 
- реализации обходить причуды аппаратной платформы (*такие как пропуск бита со знаком посреди представления из нескольких машинных слов*);
- оптимально поддерживать целевую архитектуру. 


***Ширина числа*** - это количество битов, используемых для представления значения заданного типа, не считая заполнения, но включая знак (зачастую обозначается как `N`).


***Точность*** — это количество битов, используемых для представления значения, не считая знака и заполнения.


***Заголовочный файл `<limits.h>` предоставляет минимальные и максимальные допустимые значения*** для различных целочисленных типов. 


***Допустимое значение*** - это такое, которое можно представить с помощью того количества битов, которое доступно объекту конкретного типа. 


❗***Компилятор, встречая значение, которое нельзя представить, может либо выдать диагностическое сообщение, либо преобразовать значение в представимое (хоть и некорректное).***


***Стандарт C предъявляет к размерам целых чисел 3 требования:*** 
1. область хранения любого типа данных должна иметь объем, кратный размеру объекта `unsigned char` (возможно, включая заполнение); 
2. каждый целочисленный тип должен поддерживать минимальный переносимый диапазон значений, на который можно положиться в любой реализации. 
3. меньший тип неможет быть шире большего. Поэтому 
`USHRT_MAX`, к примеру, не может быть больше `UINT_MAX`, хотя типы `unsinged short` и `unsinged int` могут иметь одинаковую ширину.


### Беззнаковые числа. Циклический перенос
***Циклический перенос (wraparound)*** происходит при выполнении арифметической операции, результат которой слишком маленький (меньше `0`) или большой (больше `2N – 1`), чтобы его можно было представить в виде 
конкретного беззнакового целочисленного типа. В этом случае берется остаток от деления значения на `N`, которое на единицу больше максимально допустимого значения итогового типа. 


❗***В языке C циклический перенос является определенным поведением.*** 


Код ниже присваивает переменной `ui` максимально 
допустимое значение и затем инкрементирует ее. Полученный результат нельзя представить как `unsigned int`, поэтому он циклически переносится 
и превращается в `0`. Если это значение декрементировать, то оно снова выйдет за рамки допустимого диапазона и в результате циклического переноса превратится в `UINT_MAX`.


```c
unsigned int ui = UINT_MAX; // 4,294,967,295 в x86

ui++;
printf("ui = %u\n", ui); // ui равно 0

ui--;
printf("ui = %u\n", ui); // ui равно 4,294,967,295
```


Ввиду циклического переноса ***беззнаковое целочисленное выражение никогда не может быть меньше `0`***. 


Например, переменная `i` в следующем цикле `for` не может иметь отрицательного значения, поэтому данный цикл никогда не прервется:


```c
for (unsigned int i = n; i >= 0; --i)
```


Чтобы избежать незапланированного поведения, необходимо удостовериться в отсутствии циклического переноса с учетом лимитов, указанных в заголовочном файле `<limits.h>`. 


Нужно быть осторожным при реализации этих проверок, поскольку в них легко ошибиться. Например, следующий код содержит дефект, так как `sum + ui` никогда не может быть больше, чем `UINT_MAX`:


```c
extern unsigned int ui, sum;

// присваиваем значения переменным ui и sum
if (sum + ui > UINT_MAX) {
    too_big();
}
else {
    sum = sum + ui;
}
```


Если результат `sum + ui` больше `UINT_MAX`, то приводится по модулю к `UINT_MAX + 1`. Таким образом вся эта проверка оказывается бесполезной и сгенерированный код всегда будет выполнять сложение. 


Чтобы исправить положение, можно вычесть `sum`
из обеих сторон неравенства с целью создать следующую эффективную проверку:


```c
extern unsigned int ui, sum;

// присваиваем значения переменным ui и sum
if (ui > UINT_MAX - sum){
    too_big();
}
else {
    sum = sum + ui;
}
```


Значение `UINT_MAX` — самое большое, какое может быть представлено как `unsigned int`, а `sum` находится где-то между `0` и `UINT_MAX`: 
- если `sum` равно `UINT_MAX`, то разность будет равна `0`; 
- если `sum` равно `0`, то результат будет равен `UINT_MAX`. 


Поскольку значение, возвращаемое этой операцией, всегда находится в допустимом диапазоне (от `0` до `UINT_MAX`), с ним не может произойти ***циклический перенос***.


Та же проблема возникает при сравнении результата арифметической операции (`j`) с `0` (минимальным беззнаковым значением):


```c
extern unsigned int i, j;
// присваиваем значения переменным i и j
if (i - j < 0) {// это невозможно
    negative();
}
else {
    i = i - j;
}
```


Поскольку беззнаковые целочисленные значения никогда не могут быть отрицательными, вычитание будет выполняться в любом случае. Вместо этого можно сравнить `j` с `i`, чтобы узнать происходит ли циклический перенос:


```c
if (j > i) {// правильно
    negative();
}
else {
    i = i - j;
}
```


Если `j > i`, то мы можем с уверенностью сказать, что результат будет циклически перенесен. Убрав из проверки операцию вычитания, исключается возможность возникновения циклического переноса во время ее выполнения.


❗***ВНИМАНИЕ: ширина***, используемая при переносе, зависит от реализации. Это значит, что на разных платформах можно получить различные результаты. Если этого не учитывать, то код не будет переносимым!

---
<a id="section_02"></a> 

## [](#top)


---
<a id="section_03"></a> 

## [](#top)



---
[readme]: ../README.md