<a id="top"></a> 

### [⬅️ README][readme]
## [Глава 2. Объекты, функции, типы и указатели](#top)
Проекты выполнены в операционной системе Ubuntu (поверх WSL 2).

По книге **Роберт С. Сикорд - Эффективный С. Профессиональное программирование**.


---
<a id="content"></a> 

### [Содержание](#top)
- ### [Объекты, функции, типы и указатели](#section_01)
- ### [Объявление переменных](#section_02)
- ### [Область видимость](#section_03) 
- ### [Срок хранения](#section_04) 
- ### [Выравнивание](#section_05)
- ### [Объектные типы](#section_06)
- ### [Функциональные типы](#section_07)
- ### [Производные типы](#section_08)


---
<a id="section_01"></a> 

### [Объекты, функции, типы и указатели](#top)
***Объект*** — это хранилище, в котором можно представлять значения. ***В стандарте C (ISO/IEC 9899:2018) объектом называется*** *"область хранилища данных в среде выполнения, содержимое которого может представлять значения"* с примечанием: *"при обращении к объекту можно считать, что он обладает определенным типом"*. Один из примеров объекта — переменная.


***Переменные*** имеют ***объявленный тип***, который говорит о том, какого рода объект представляет его значение. Например, объект типа ***int*** содержит целочисленное значение. Важность типа объясняется тем, что набор битов, представляющий объект одного типа, скорее всего, будет иметь другое значение, если его интерпретировать как объект другого типа. Например, в ***IEEE 754*** (стандарт IEEE для арифметических операций с плавающей запятой) *число 1 представлено как 0x3f800000* (IEEE 754–2008). Но если интерпретировать тот же набор битов *как целое число, то вместо 1 получится значение 1 065 353 216*.


***Функции*** не являются объектами, но тоже имеют тип. Тип функции характеризуется как ее возвращаемым значением, так и числом и типами ее параметров.


В C есть ***указатели***, которые можно считать ***адресами — областями памяти***, в которых хранятся объекты или функции. Тип указателя, основанный на типе функции или объекта, называется ***ссылочным типом***. Указатель, имеющий ссылочный тип T, называют ***указателем на T***.


***Объекты и функции*** — это разные вещи, и потому ***объектные указатели отличаются от функциональных и их нельзя использовать как взаимозаменяемые***.


---
<a id="section_02"></a> 

## [Объявление переменных](#top)
***Идентификатор*** — наименование, по которому можно обращаться к переменной.


***У каждого объекта есть срок хранения***, который определяет его ***время жизни (lifetime)*** — период выполнения программы, на протяжении которого этот объект существует, где-то хранится, имеет постоянный адрес и сохраняет последнее присвоенное ему значение. К объектам нельзя обращаться вне данного периода


***Локальные переменные*** имеют ***автоматический срок хранения (storage duration)***, то есть они существуют, пока поток выполнения не покинет блок, в котором они определены.


***Параметры*** - это объекты, которые объявляются вместе с функцией и получают значения при входе в нее.


***Аргументы*** - это выражения, разделяемые запятыми, которые указываются в выражении вызова функции.


***В языке C передача аргументов при вызове происходит по значению***, т.е. когда вы предоставляете функции аргумент, его значение копируется в отдельную переменную, доступную для использования внутри этой функции. 


***Унарная операция * в выражениях внутри функции разыменовывает указатель на объект*** - берет значение по адресу.


***Унарная операция &*** используется для ***взятия адреса***: она генерирует указатель на свой операнд. 


***Передача аргументов по ссылке:*** сначала генерируются адреса объектов, которые передаются по значению, а затем они разыменовываются для доступа к исходным объектам.


---
<a id="section_03"></a> 

## [Область видимость](#top)
Объекты, функции, макросы и другие идентификаторы языка C имеют ***область видимости***, которая определяет, где к ним можно обращаться. В языке C область видимости может быть следующих типов:
- ***на уровне файла:*** охватывает весь файл, в котором он находится, а также любые другие файлы, подключенные после его объявления (например, если объявление сделано за пределами 
какого-либо блока или списка параметров);
- ***на уровне блока:*** объявленный идентифиатор доступен только внутри этого блока (например, если объявление происходит внутри блока или списка параметров);
- ***на уровне прототипа:*** область видимости ограниченая ее объявлением (то есть прототипом) (например, если объявление происходит внутри списка параметров прототипа 
функции но не в ее теле);
- ***на уровне функции:*** охватывает определение идентификатора между открывающей ({) и закрывающей (}) скобками. Единственным видом идентификаторов, который имеет такую область видимости, являются ***метки*** — идентификаторы, завершающиеся двоеточием и определяющие оператор в функции, к которому может перейти управление


***Области видимости*** могут быть ***вложенными*** и находиться как ***внутри***, так и ***снаружи*** относительно других областей видимости. ***Внутренняя область имеет доступ к наружной, но не наоборот***. 


Если объявить один и тот же идентификатор как во внутренней, так и в наружной областях видимости, то ***внутренняя версия перекрывает наружную, имея более высокий приоритет***. В данном случае имя идентификатора будет ссылаться на объект во внутренней области видимости; объект из наружной области скрывается, и на него нельзя сослаться по имени. 


---
<a id="section_04"></a> 

## [Срок хранения](#top)
***Объекты имеют срок хранения***, который определяет их ***время жизни***. В целом сроки хранения бывают 4-х видов: 
- автоматические;
- статические; 
- потоковые;
- выделенные. 


***Объекты с автоматическим сроком хранения*** объявляются внутри блока или в качестве параметров функции. Их время жизни начинается в момент выполнения блока, в котором они объявлены, и заканчивается при его завершении. Если блок вызывается рекурсивно, то при каждом вызове создается новый объект с собственным сроком хранения.


❗***Область видимости*** и ***время жизни*** — совершенно разные понятия. Первое относится к идентификаторам, а второе — к объектам. ***Областью видимости идентификатора*** является участок кода, в котором к объекту, обозначенному этим идентификатором, можно получить доступ по его имени. ***Время жизни объекта*** — это период, на протяжении которого он существует.


Объекты, объявленные на уровне файла, имеют ***статический срок хранения***. Их время жизни охватывает весь период выполнения программы, а значения, которые в них хранятся, инициализируются еще до ее запуска. Можно объявить переменную со статическим сроком хранения внутри блочной области видимости, используя спецификатор класса хранения ***static***.


❗***При разработке ПО рекомендуется как можно сильнее ограничивать область видимости объектов.***


Статические объекты должны инициализироваться с помощью константного значения, а не переменной:


```c
int *func(int i) 
{
  const int j = i; // правильно
  static int k = j; // ошибка
  return &k;
}
```


***К константным значениям*** относятся константы-литералы (например, `1`, `'a'` или `0xFF`), члены enum и результаты работы операций, таких как alignof или sizeof, но не объекты со спецификатором const.


***Потоковый срок хранения*** используется в конкурентном программировании. 


***Динамический срок хранения*** относится к динамически выделяемой памяти.


---
<a id="section_05"></a> 

## [Выравнивание](#top)
***Выравнивание (alignment)*** - определяет количество байтов между смежными адресами, в которых может быть сохранен заданный объект. Типы объектов имеют требования к выравниванию, ограничивающие адреса, которые могут выделяться для объектов этих типов.  


❗Некоторые машинные инструкции могут выполнять многобайтный доступ к данным, не выровненным по границе машинного слова, но ***это может отрицательно сказаться на производительности***. 


***Машинное слово*** — естественная единица фиксированного размера для измерения данных, с которой работают инструкции или аппаратные механизмы процессора. 


В целом программистам на C не нужно беспокоиться об этих требованиях, поскольку компилятор самостоятельно выбирает для своих различных типов подходящее выравнивание. Гарантируется, что память, выделенная с помощью `malloc`, будет достаточно выровненной для всех стандартных типов, включая массивы и структуры. 


❗***В редких случаях решения компилятора***, используемые по умолчанию, ***приходится переопределять*** — например, чтобы выровнять данные на границах строк кэша, адреса должны быть кратны степеням двойки. Для выполнения этих требований традиционно задействуются команды компоновки, выделение дополнительной памяти с помощью `malloc` с последующим округлением пользовательского адреса вверх или другие операции с применением нестандартных средств.


***В С11 выравнивание представляется*** как неотрицательное целое число типа `size_t`. Корректное выравнивание должно быть степенью двойки. 


В следующем примере ***спецификатор выравнивания*** позволяет убедиться в том, что значение `good_buff` как следует выровнено (у `bad_buff` может быть неправильное выравнивание для выражений доступа к членам).


Использование ключевого слова `_Alignas`


```c
struct S {
    int i;
    double d;
    char c;
}

int main(void) {
    unsigned char bad_buff[sizeof(struct S)];
    _Alignas(struct S) unsigned char good_buff[sizeof(struct S)];

    // неправильное выравнивание указателя
    struct S *bad_s_ptr = (struct S *)bad_buff;

    // правильное выравнивание указателя
    struct S *good_s_ptr = (struct S *)good_buff;
}
```


❗В примере выше ***массивы не инициализированы***, поэтому ***разыменовывать указатели `bad_s_ptr` и `good_s_ptr` нельзя*** в любом случае - ***это неопределенное состояние.***


---
<a id="section_06"></a> 

## [Объектные типы](#top)
### Логические (булевы) типы
|Тип|Значения|Заголовки|
|---|---|---|
|`_Bool`|0/1||
|`bool` |`false`/`true`|`<stdbool.h>`|


```c
#include

_Bool flag1 = 0;
bool flag2 = false;
```


### Символьные типы
|Тип|Занимает память|Диапазон значений|
|---|---|---|
|`char`|1 байт|-128...127|
|`unsigned char` |1 байт|0...255|
|`signed char` |1 байт|-128...127|
|`wchar_t` (Windows) |2 байта|0...65 535|
|`wchar_t` (Linux) |4 байта|0...4 294 967 295|


`char` — **отдельный тип, несовместимый с двумя другими***.


***Для представления символьных данных*** в программах на языке C обычно используется тип `char`. Тип `char` не предназначен для целочисленных данных; ***для небольших целых значений со знаком или без более безопасно использовать*** `signed char` или `unsigned char` соответственно.


Чтобы решить проблему использования символов, не входящих в диапазон ***ANCI/ASCI***, комитет во главе стандарта C определил новый, ***широкий тип*** с поддержкой больших наборов символов - `wchar_t`. Этот тип обычно занимает больше места, чем базовые символы. 


### Целочисленные типы
|Тип|Занимает память|Диапазон значений|
|---|---|---|
|`signed char`|1 байт|-128...127|
|`signed short`/`short`|2 байта|-32 768...32 767|
|`unsigned short`|2 байта|0...65 535|
|`signed int`/`int` (32-bit)|2 байта|-32 768...32 767|
|`signed int`/`int` (64-bit)|4 байта|-2 147 483 648...2 147 483 647|
|`unsigned int` (32-bit)|2 байта|0...65 535|
|`unsigned int` (64-bit)|4 байта|0...4 294 967 295|
|`signed long`/`long`|4 байта|-2 147 483 648...2 147 483 647|
|`unsigned long`|4 байта|0...4 294 967 295|
|`signed long long`/`long long`|8 байт|-9 223 372 036 854 775 808...9 223 372 036 854 775 807|
|`unsigned long long`|8 байт|0...18 446 744 073 709 551 615|


Конкретный размер разных целочисленных типов можно определить по минимально и максимально допустимым значениям, указанным в заголовочном файле `<limits.h>`.


Тип `int` обычно имеет естественный размер, вытекающий из архитектуры среды выполнения. Таким образом, в 16-битной архитектуре это 16 бит, а в 32-битной — 32 бита. Выделить целочисленные значения нужного вам размера можно с помощью определения типов наподобие `uint32_t` из заголовочного файла `<stdint.h>` или `<inttypes.h>`. В этих файлах содержатся определения самых широких целочисленных типов, которые доступны на 
конкретной платформе: `uintmax_t` и `intmax_t`.


### Типы с плавающей запятой
|Тип|Занимает память|Диапазон значений|
|---|---|---|
|`float`|4 байта|+/-3.4E-38...3.14E+38|
|`double`|8 байт|+/-1.7E-308...1.7E+308|
|`long double`|10 байт|+/-3.4E-4932...1.1E+4932|


Стандарт языка С допускает разные варианты представлений чисел с плавающей запятой, и в большинстве систем реализован соответствующий стандарт ***IEEE (IEEE 754–2008)***. Выбор того или иного варианта зависит от реализации.


### Перечисления
***Перечисление (enum, от enumeration)*** позволяет определить тип, который назначает имена (перечислители) целочисленным значениям в ситуациях, когда требуется перечисляемый набор постоянных значений. Ниже показаны примеры перечислений:


```c
enum day { sun, mon, tue, wed, thu, fri, sat };

enum cardinal_points { 
  north = 0, 
  east = 90, 
  south = 180, 
  west = 270 
};

enum months { 
  jan = 1, 
  feb, 
  mar, 
  apr, 
  may, 
  jun, 
  jul, 
  aug, 
  sep, 
  oct, 
  nov, 
  dec 
};
```


Если не присвоить значение первому перечислителю с помощью операции `=`, то его перечисляемая константа будет равна 0, и каждый следующий перечислитель без знака `=` будет прибавлять 1 к предыдущей константе. 


❗***Использование операции `=` может привести к повторению значений, что чревато проблемами, если вы ошибочно предполагаете, будто все значения должны быть уникальными.*** 

Значения констант в перечислении должны быть совместимы с типом `int`, хотя в действительности их тип зависит от реализации. Например, ***Visual C++*** использует `signed int`, а ***GCC*** — `unsigned int`.


### Тип void
Ключевое слово `void` (само по себе) означает ***"не может содержать никаких значений"***: 
- с его помощью можно сигнализировать о том, что ***функция не возвращает значение или не принимает аргументов (если указать его в качестве единственного параметра)***;
- производный тип `void *` означает, что ***указатель может ссылаться на любой объект***.


---
<a id="section_07"></a> 

## [Функциональные типы](#top)
***Функциональные типы*** являются производными — *основаны на типе возвращаемого значения, а также на количестве и типах параметров функции*. 


❗***Тип возвращаемого значения не может быть массивом.***


❗***При объявлении функции*** нужно указать ее имя и тип значения, которое она возвращает. 


Примеры объявлений функциональных типов:


```c
int f(void);

int * fip();

void g(int i, int j);

void h(int, int);
```


В объявлении функции перечислять параметры не обязательно. Но если этого не делать, то ***можно столкнуться с проблемами***. 


Если записать объявление для `fip` в ***C++***, то получится функция, которая не принимает аргументов и возвращает `int *`. В языке ***C*** эта же функция имеет тот же возвращаемый тип, но ***принимает любое количество параметров любого типа***. 


❗В ***C*** никогда не следует объявлять функции с пустым списком параметров:
1. это устаревшая возможность языка, которая в будущем может исчезнуть; 
2. код может быть перенесен в C++, поэтому нужно явно перечислять типы параметров и использовать `void`, если функция ничего не принимает.


***Прототип функции*** — это сочетание типа функции и списка с типами ее параметров. Он сообщает компилятору о количестве и типах параметров, которые она принимает. С помощью этой информации компиляторы следят за тем, чтобы в ***определении функции*** и в любых ее вызовах использовалось корректное количество параметров с подходящими типами.


***Определение функции*** содержит ее непосредственную реализацию:


```c
int max(int a, int b)
{ 
  return a > b ? a : b; 
}
```


---
<a id="section_08"></a> 

## [Производные типы](#top)
### Указатели
***Тип указателя (ссылочный тип)*** является производным от типа функции или объекта, на 
которые он указывает. 


***Указатель*** предоставляет ссылку на сущность ссылочного типа


```c
int *ip;

char *cp;

void *vp;
```


Операция `&` позволяет получить адрес объекта или функции. 


```c
int i = 17;
int *ip = &i;
```


Выше объявляется переменная `ip` в качестве указателя на `int` и ей присваивается адрес `i`. 


Можно применить операцию `&` к результату выполнения операции `*`:


```c
ip = &*ip;
```


В результате разыменования `ip` с помощью операции ***косвенного обращения*** можно получить сам объект `i`. Адрес `*ip`, полученный с помощью `&`, является указателем, поэтому *эти две операции компенсируют друг друга*.


***Унарная операция `*` возвращает значение***, на которое ссылается ***указатель***. Она обозначает ***косвенность*** и работает только с указателями. 


Если операнд указывает на функцию, то результатом использования `*` будет ее ***обозначение (designator)***, а если на объект, то результатом будет ***значение этого объекта***. 


❗***Если указатель не ссылается на действительный объект или функцию, то может произойти что-то плохое.***


### Массивы
***Массив*** — это последовательность объектов одного и того же типа, выделенных один за другим. ***Тип массива характеризуется*** типом и количеством его элементов. 


```c
int ia[11];

float *afp[17];
```


Cледующий демонстрационный фрагмент кода создает 
строку "0123456789":


```c
// В первой строчке объявляется массив типа char размером 11. 
// В результате выделяется место, достаточное для хранения десяти символов + \0 ("нуль-символ").
char str[11];

for (unsigned int i = 0; i < 10; ++i) {
  // str автоматически преобразуется в указатель на первый элемент массива
  // благодаря наличию операций индексации ([]) и сложения (+) выражение str[i] идентично *(str + i)
  str[i] = '0' + i;
}

str[10] = '\0';
```


Если операнд унарной операции `&` является результатом операции `[]`, то его можно было бы получить, убрав `&` и заменив `[]` операцией `+`. Например, выражение `&str[10]` эквивалентно `str + 10`.


Можно объявлять ***многомерные массивы***. Ниже показана функция `main`, в которой объявляется двумерный массив `arr` типа `int` размером `5 × 3`, который еще называют ***матрицей***.


```c
void func(int arr[5]);

int main(void) {
  unsigned int i = 0;
  unsigned int j = 0;
 
  int arr[3][5];
  func(arr[i]);
  
  int x = arr[i][j];
  return 0;
}
```


Когда вы используется выражение `arr[i]` (эквивалентное `*(arr+i)`), происходит следующее.
1. Массив `arr` преобразуется в указатель на исходный массив из пяти элементов типа `int`, начиная с `arr[i]`.
2. Индекс `i` подстраивается под тип `arr` за счет умножения на размер одного массива из пяти объектов `int`.
3. Результаты первых двух шагов складываются.
4. Происходит косвенное обращение к результату, чтобы получить массив из пяти элементов типа `int`.


При использовании выражения `arr[i][j]` массив преобразуется в указатель на первый элемент типа `int`, поэтому `arr[i][j]` возвращает объект типа `int`.


### Определения типов
Ключевое слово `typedef` используется ***для создания псевдонима существующего типа; оно никогда не создает новый тип***. Например:


```c
typedef unsigned int uint_type;

typedef signed char schar_type, *schar_p, (*fp)(void);
```


В 1-ой строчке объявляется `uint_type` в качестве псевдонима для типа `unsigned int`. 


Во 2-ой строчке объявляются псевдонимы `schar_type`, `schar_p` и `fp` для типов `signed char`, `signed char *` и `signed char(*) (void)` соответственно. 


❗Идентификаторы, находящиеся в стандартных заголовочных файлах и заканчивающиеся на `_t`, являются определениями типов (псевдонимами для существующих типов). В целом не нужно соблюдать это соглашение об именовании в собственном коде, поскольку стандарт ***C*** резервирует идентификаторы, соответствующие шаблонам `int[0-9a-z_]*_t` и `uint[0-9a-z_]*_t`, а спецификация
***POSIX (Portable Operating System Interface — переносимый интерфейс операционных систем)*** резервирует все идентификаторы, которые заканчиваются на `_t`. В случае определения идентификатора с таким именем может возникнуть
конфликт с именами, которые используются реализацией. Это, в свою очередь, может спровоцировать проблемы, которые будет сложно диагностировать.


### Структуры
***Структура (`struct`)*** содержит последовательно выделенные объекты-члены. Каждый объект обладает собственным именем и может иметь 
отдельный тип. Ниже объявляется объект с идентификатором `sigline` и типом `struct sigrecord`, а указатель на объект типа `struct sigrecord` имеет идентификатор `sigline_p`.


```c
struct sigrecord {
  int signum;
  char signame[20];
  char sigdesc[100];
} sigline, *sigline_p;
```


***Структуры*** позволяют объявлять коллекции связанных между собой объектов. Они особенно полезны для группирования объектов, которые часто передаются вместе в виде аргументов функций; 


Для обращения к членам объекта структурных типов служит ***операция доступа (`.`)***. Если есть указатель на структуру, то ***для обращения к ее членам предусмотрена операция `->`***. 


```c
sigline.signum = 5;
strcpy(sigline.signame, "SIGINT");
strcpy(sigline.sigdesc, "Interrupt from keyboard");

sigline_p = &sigline;
sigline_p->signum = 5;
strcpy(sigline_p->signame, "SIGINT");
strcpy(sigline_p->sigdesc, "Interrupt from keyboard");
```

В первых трех строчках выше происходит прямой доступ к членам объекта `sigline` с помощью операции доступа (`.`). 

Далее выполняется присваиваем указателю `sigline_p` адрес объекта `sigline`. В заключительных трех строчках программы происходит косвенное обращание к членам объекта `sigline`
через указатель `sigline_p`, с использованием операции `->`.


### Объединения
***Объединения (`union`)*** похожи на структуры, только ***их члены используют одну и ту же память***. 


❗В один момент времени ***объединение (`union`)*** может содержать объект одного типа, а в другой момент времени — объект другого типа, но никогда не может содержать оба объекта сразу. 


***Объединения*** используются в основном для экономии памяти.

Ниже показано объединение `u`, которое содержит три структуры: `n`, `ni` и `nf`. Его можно задействовать в дереве, графе и других структурах 
данных с узлами, которые могут содержать как целочисленные (`ni`), так и вещественные значения (`nf`).


```c
union {
  struct {
    int type;
  } n;
  
  struct {
    int type;
    int intnode;
  } ni;
 
  struct {
    int type;
    double doublenode;
  } nf;
} u;

u.nf.type = 1;
u.nf.doublenode = 3.14;
```


Доступ к членам объединения осуществляется также, как и в случае со структурами.


В представленном выше примере член структуры `nf` с именем `type` доступен в виде `u.nf.type`, а доступ к члену `doublenode` происходит с помощью выражения `u.nf.doublenode`. 


Код, использующий такое объединение, обычно выясняет тип узла, проверяя значение, хранящееся в `u.n.type`, и затем, в зависимости от результата, обращается либо к `intnode`, либо к `doublenode`. Если бы это было реализовано в виде ***структуры***, то в каждом узле было бы выделено место как для `intnode`, так и для `doublenode`. Использование объединения позволяет задействовать одно и то же место для обоих членов.


### Теги
***Теги*** — это специальный механизм именования структур, объединений и перечислений. Например, идентификатор `s`, представленный в следующей структуре, является тегом:


```c
struct s {
 //---snip---
};
```


❗Сам по себе ***тег не является именем типа, и его нельзя использовать для объявления переменных***. 


Вместо этого переменные таких типов следует объявлять следующим образом:


```c
struct s v; // экземпляр структуры s
struct s *p; // указатель на структуру s
```


❗***Названия объединений и перечислений — тоже теги, а не типы.*** Это значит, их недостаточно для объявления переменной. Например:


```c
enum day { sun, mon, tue, wed, thu, fri, sat };

day today; // ошибка
enum day tomorrow; // правильно
```


***Теги структур, объединений и перечислений*** определяются в собственном пространстве имен, отдельно от обычных идентификаторов. Благодаря 
этому программа на ***C*** может иметь в одной области видимости тег и другой идентификатор, который выглядит точно так же:


```c
enum status { ok, fail }; // перечисление
enum status status(void); // функция
```


Даже можно объявить объект `s` типа `struct s`:


```c
struct s s;
```


Теги структур можно считать именами типов и определять для них псевдонимы с помощью `typedef`:


```c
typedef struct s { int x; } t;
```


Теперь можно объявлять переменные типа `t`, а не `struct s`. Имя тега в `struct`, `union` и `enum` указывать не обязательно, поэтому можно его опустить:


```c
typedef struct { int x; } t;
```


Это будет работать всегда, кроме тех случаев, когда структура содержит указатель на саму себя:


```c
struct tnode {
  int count;
  struct tnode *left;
  struct tnode *right;
};
```


Если опустить тег в первой строчке, то компилятору это может не понравиться, поскольку структура, упоминаемая в третьей и четвертой 
строчках, еще не объявлена или просто потому, что нигде не используется. 


Таким образом, не остается ничего другого, как объявить для данной структуры тег. Также можно объявить `typedef`:


```c
typedef struct tnode {
  int count;
  struct tnode *left;
  struct tnode *right;
} tnode;
```


Большинство программистов на ***C*** используют для тегов и `typedef` разные имена, хотя можно обойтись и общим именем. 

Можно определить данный тип перед структурой; это позволит объявить члены `left` и `right`, которые ссылаются на другие объекты типа `tnode`:


```c
typedef struct tnode tnode;

struct tnode {
  int count;
  tnode *left
  tnode *right;
} tnode;
```


***Определения типов*** могут сделать код более понятным не только в случае их использования со структурами. Например, во всех трех объявлениях 
функции `signal`, представленных ниже, указан один и тот же тип:


```c
typedef void fv(int), (*pfv)(int);

void (*signal(int, void (*)(int)))(int);

fv *signal(int, fv *);

pfv signal(int, pfv);
```




---
[readme]: ../README.md