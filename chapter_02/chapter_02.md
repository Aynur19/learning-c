<a id="top"></a> 

### [⬅️ README][readme]
## [Глава 2. Объекты, функции, типы и указатели](#top)
Проекты выполнены в операционной системе Ubuntu (поверх WSL 2).

По книге **Роберт С. Сикорд - Эффективный С. Профессиональное программирование**.


---
<a id="content"></a> 

### [Содержание](#top)
- ### [Объекты, функции, типы и указатели](#section_01)
- ### [Объявление переменных](#section_02)
- ### [Область видимость](#section_03) 
- ### [Срок хранения](#section_04) 
- ### [Выравнивание](#section_05)
- ### [Объектные типы](#section_06)


---
<a id="section_01"></a> 

### [Объекты, функции, типы и указатели](#top)
***Объект*** — это хранилище, в котором можно представлять значения. ***В стандарте C (ISO/IEC 9899:2018) объектом называется*** *"область хранилища данных в среде выполнения, содержимое которого может представлять значения"* с примечанием: *"при обращении к объекту можно считать, что он обладает определенным типом"*. Один из примеров объекта — переменная.


***Переменные*** имеют ***объявленный тип***, который говорит о том, какого рода объект представляет его значение. Например, объект типа ***int*** содержит целочисленное значение. Важность типа объясняется тем, что набор битов, представляющий объект одного типа, скорее всего, будет иметь другое значение, если его интерпретировать как объект другого типа. Например, в ***IEEE 754*** (стандарт IEEE для арифметических операций с плавающей запятой) *число 1 представлено как 0x3f800000* (IEEE 754–2008). Но если интерпретировать тот же набор битов *как целое число, то вместо 1 получится значение 1 065 353 216*.


***Функции*** не являются объектами, но тоже имеют тип. Тип функции характеризуется как ее возвращаемым значением, так и числом и типами ее параметров.


В C есть ***указатели***, которые можно считать ***адресами — областями памяти***, в которых хранятся объекты или функции. Тип указателя, основанный на типе функции или объекта, называется ***ссылочным типом***. Указатель, имеющий ссылочный тип T, называют ***указателем на T***.


***Объекты и функции*** — это разные вещи, и потому ***объектные указатели отличаются от функциональных и их нельзя использовать как взаимозаменяемые***.


---
<a id="section_02"></a> 

## [Объявление переменных](#top)
***Идентификатор*** — наименование, по которому можно обращаться к переменной.


***У каждого объекта есть срок хранения***, который определяет его ***время жизни (lifetime)*** — период выполнения программы, на протяжении которого этот объект существует, где-то хранится, имеет постоянный адрес и сохраняет последнее присвоенное ему значение. К объектам нельзя обращаться вне данного периода


***Локальные переменные*** имеют ***автоматический срок хранения (storage duration)***, то есть они существуют, пока поток выполнения не покинет блок, в котором они определены.


***Параметры*** - это объекты, которые объявляются вместе с функцией и получают значения при входе в нее.


***Аргументы*** - это выражения, разделяемые запятыми, которые указываются в выражении вызова функции.


***В языке C передача аргументов при вызове происходит по значению***, т.е. когда вы предоставляете функции аргумент, его значение копируется в отдельную переменную, доступную для использования внутри этой функции. 


***Унарная операция * в выражениях внутри функции разыменовывает указатель на объект*** - берет значение по адресу.


***Унарная операция &*** используется для ***взятия адреса***: она генерирует указатель на свой операнд. 


***Передача аргументов по ссылке:*** сначала генерируются адреса объектов, которые передаются по значению, а затем они разыменовываются для доступа к исходным объектам.


---
<a id="section_03"></a> 

## [Область видимость](#top)
Объекты, функции, макросы и другие идентификаторы языка C имеют ***область видимости***, которая определяет, где к ним можно обращаться. В языке C область видимости может быть следующих типов:
- ***на уровне файла:*** охватывает весь файл, в котором он находится, а также любые другие файлы, подключенные после его объявления (например, если объявление сделано за пределами 
какого-либо блока или списка параметров);
- ***на уровне блока:*** объявленный идентифиатор доступен только внутри этого блока (например, если объявление происходит внутри блока или списка параметров);
- ***на уровне прототипа:*** область видимости ограниченая ее объявлением (то есть прототипом) (например, если объявление происходит внутри списка параметров прототипа 
функции но не в ее теле);
- ***на уровне функции:*** охватывает определение идентификатора между открывающей ({) и закрывающей (}) скобками. Единственным видом идентификаторов, который имеет такую область видимости, являются ***метки*** — идентификаторы, завершающиеся двоеточием и определяющие оператор в функции, к которому может перейти управление


***Области видимости*** могут быть ***вложенными*** и находиться как ***внутри***, так и ***снаружи*** относительно других областей видимости. ***Внутренняя область имеет доступ к наружной, но не наоборот***. 


Если объявить один и тот же идентификатор как во внутренней, так и в наружной областях видимости, то ***внутренняя версия перекрывает наружную, имея более высокий приоритет***. В данном случае имя идентификатора будет ссылаться на объект во внутренней области видимости; объект из наружной области скрывается, и на него нельзя сослаться по имени. 


---
<a id="section_04"></a> 

## [Срок хранения](#top)
***Объекты имеют срок хранения***, который определяет их ***время жизни***. В целом сроки хранения бывают 4-х видов: 
- автоматические;
- статические; 
- потоковые;
- выделенные. 


***Объекты с автоматическим сроком хранения*** объявляются внутри блока или в качестве параметров функции. Их время жизни начинается в момент выполнения блока, в котором они объявлены, и заканчивается при его завершении. Если блок вызывается рекурсивно, то при каждом вызове создается новый объект с собственным сроком хранения.


❗***Область видимости*** и ***время жизни*** — совершенно разные понятия. Первое относится к идентификаторам, а второе — к объектам. ***Областью видимости идентификатора*** является участок кода, в котором к объекту, обозначенному этим идентификатором, можно получить доступ по его имени. ***Время жизни объекта*** — это период, на протяжении которого он существует.


Объекты, объявленные на уровне файла, имеют ***статический срок хранения***. Их время жизни охватывает весь период выполнения программы, а значения, которые в них хранятся, инициализируются еще до ее запуска. Можно объявить переменную со статическим сроком хранения внутри блочной области видимости, используя спецификатор класса хранения ***static***.


❗***При разработке ПО рекомендуется как можно сильнее ограничивать область видимости объектов.***


Статические объекты должны инициализироваться с помощью константного значения, а не переменной:


```c
int *func(int i) 
{
  const int j = i; // правильно
  static int k = j; // ошибка
  return &k;
}
```


***К константным значениям*** относятся константы-литералы (например, `1`, `'a'` или `0xFF`), члены enum и результаты работы операций, таких как alignof или sizeof, но не объекты со спецификатором const.


***Потоковый срок хранения*** используется в конкурентном программировании. 


***Динамический срок хранения*** относится к динамически выделяемой памяти.


---
<a id="section_05"></a> 

## [Выравнивание](#top)
***Выравнивание (alignment)*** - определяет количество байтов между смежными адресами, в которых может быть сохранен заданный объект. Типы объектов имеют требования к выравниванию, ограничивающие адреса, которые могут выделяться для объектов этих типов.  


❗Некоторые машинные инструкции могут выполнять многобайтный доступ к данным, не выровненным по границе машинного слова, но ***это может отрицательно сказаться на производительности***. 


***Машинное слово*** — естественная единица фиксированного размера для измерения данных, с которой работают инструкции или аппаратные механизмы процессора. 


В целом программистам на C не нужно беспокоиться об этих требованиях, поскольку компилятор самостоятельно выбирает для своих различных типов подходящее выравнивание. Гарантируется, что память, выделенная с помощью `malloc`, будет достаточно выровненной для всех стандартных типов, включая массивы и структуры. 


❗***В редких случаях решения компилятора***, используемые по умолчанию, ***приходится переопределять*** — например, чтобы выровнять данные на границах строк кэша, адреса должны быть кратны степеням двойки. Для выполнения этих требований традиционно задействуются команды компоновки, выделение дополнительной памяти с помощью `malloc` с последующим округлением пользовательского адреса вверх или другие операции с применением нестандартных средств.


***В С11 выравнивание представляется*** как неотрицательное целое число типа `size_t`. Корректное выравнивание должно быть степенью двойки. 


В следующем примере ***спецификатор выравнивания*** позволяет убедиться в том, что значение `good_buff` как следует выровнено (у `bad_buff` может быть неправильное выравнивание для выражений доступа к членам).


Использование ключевого слова `_Alignas`


```c
struct S {
    int i;
    double d;
    char c;
}

int main(void) {
    unsigned char bad_buff[sizeof(struct S)];
    _Alignas(struct S) unsigned char good_buff[sizeof(struct S)];

    // неправильное выравнивание указателя
    struct S *bad_s_ptr = (struct S *)bad_buff;

    // правильное выравнивание указателя
    struct S *good_s_ptr = (struct S *)good_buff;
}
```


❗В примере выше ***массивы не инициализированы***, поэтому ***разыменовывать указатели `bad_s_ptr` и `good_s_ptr` нельзя*** в любом случае - ***это неопределенное состояние.***


---
<a id="section_06"></a> 

## [Объектные типы](#top)
### Логические (булевы) типы
|Тип|Значения|Заголовки|
|---|---|---|
|`_Bool`|0/1||
|`bool` |`false`/`true`|`<stdbool.h>`|


```c
#include

_Bool flag1 = 0;
bool flag2 = false;
```


### Символьные типы
|Тип|Занимает память|Диапазон значений|
|---|---|---|
|`char`|1 байт|-128...127|
|`unsigned char` |1 байт|0...255|
|`signed char` |1 байт|-128...127|
|`wchar_t` (Windows) |2 байта|0...65 535|
|`wchar_t` (Linux) |4 байта|0...4 294 967 295|


`char` — **отдельный тип, несовместимый с двумя другими***.


***Для представления символьных данных*** в программах на языке C обычно используется тип `char`. Тип `char` не предназначен для целочисленных данных; ***для небольших целых значений со знаком или без более безопасно использовать*** `signed char` или `unsigned char` соответственно.


Чтобы решить проблему использования символов, не входящих в диапазон ***ANCI/ASCI***, комитет во главе стандарта C определил новый, ***широкий тип*** с поддержкой больших наборов символов - `wchar_t`. Этот тип обычно занимает больше места, чем базовые символы. 


### Целочисленные типы
|Тип|Занимает память|Диапазон значений|
|---|---|---|
|`signed char`|1 байт|-128...127|
|`signed short`/`short`|2 байта|-32 768...32 767|
|`unsigned short`|2 байта|0...65 535|
|`signed int`/`int` (32-bit)|2 байта|-32 768...32 767|
|`signed int`/`int` (64-bit)|4 байта|-2 147 483 648...2 147 483 647|
|`unsigned int` (32-bit)|2 байта|0...65 535|
|`unsigned int` (64-bit)|4 байта|0...4 294 967 295|
|`signed long`/`long`|4 байта|-2 147 483 648...2 147 483 647|
|`unsigned long`|4 байта|0...4 294 967 295|
|`signed long long`/`long long`|8 байт|-9 223 372 036 854 775 808...9 223 372 036 854 775 807|
|`unsigned long long`|8 байт|0...18 446 744 073 709 551 615|


Конкретный размер разных целочисленных типов можно определить по минимально и максимально допустимым значениям, указанным в заголовочном файле `<limits.h>`.


Тип `int` обычно имеет естественный размер, вытекающий из архитектуры среды выполнения. Таким образом, в 16-битной архитектуре это 16 бит, а в 32-битной — 32 бита. Выделить целочисленные значения нужного вам размера можно с помощью определения типов наподобие `uint32_t` из заголовочного файла `<stdint.h>` или `<inttypes.h>`. В этих файлах содержатся определения самых широких целочисленных типов, которые доступны на 
конкретной платформе: `uintmax_t` и `intmax_t`.


### Типы с плавающей запятой
|Тип|Занимает память|Диапазон значений|
|---|---|---|
|`float`|4 байта|+/-3.4E-38...3.14E+38|
|`double`|8 байт|+/-1.7E-308...1.7E+308|
|`long double`|10 байт|+/-3.4E-4932...1.1E+4932|


Стандарт языка С допускает разные варианты представлений чисел с плавающей запятой, и в большинстве систем реализован соответствующий стандарт ***IEEE (IEEE 754–2008)***. Выбор того или иного варианта зависит от реализации.


### Перечисления
***Перечисление (enum, от enumeration)*** позволяет определить тип, который назначает имена (перечислители) целочисленным значениям в ситуациях, когда требуется перечисляемый набор постоянных значений. Ниже показаны примеры перечислений:


```c
enum day { sun, mon, tue, wed, thu, fri, sat };

enum cardinal_points { 
  north = 0, 
  east = 90, 
  south = 180, 
  west = 270 
};

enum months { 
  jan = 1, 
  feb, 
  mar, 
  apr, 
  may, 
  jun, 
  jul, 
  aug, 
  sep, 
  oct, 
  nov, 
  dec 
};
```


Если не присвоить значение первому перечислителю с помощью операции `=`, то его перечисляемая константа будет равна 0, и каждый следующий перечислитель без знака `=` будет прибавлять 1 к предыдущей константе. 


❗***Использование операции `=` может привести к повторению значений, что чревато проблемами, если вы ошибочно предполагаете, будто все значения должны быть уникальными.*** 

Значения констант в перечислении должны быть совместимы с типом `int`, хотя в действительности их тип зависит от реализации. Например, ***Visual C++*** использует `signed int`, а ***GCC*** — `unsigned int`.


### Тип void
Ключевое слово `void` (само по себе) означает ***"не может содержать никаких значений"***: 
- с его помощью можно сигнализировать о том, что ***функция не возвращает значение или не принимает аргументов (если указать его в качестве единственного параметра)***;
- производный тип `void *` означает, что ***указатель может ссылаться на любой объект***.






---
[readme]: ../README.md