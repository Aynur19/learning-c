<a id="top"></a> 

# Изучение C

Проекты выполнены в операционной системе Ubuntu (поверх WSL 2).

По книге **Роберт С. Сикорд - Эффективный С. Профессиональное программирование**.


---
<a id="content"></a> 

### [Содержание](#content)
[Зaметки по главам](#section_01)
- [1. Глава 1. Знакомство с С](#section_01_01)

---
<a id="section_01"></a> 

## [Заметки по главам](#content)


---
<a id="section_01_01"></a> 

### [Глава 1. Знакомство с С](#content)
***Язык C*** имеет 2 потенциальные среды выполнения: 
1. ***минимальную (freestanding)***
2. ***полноценную (hosted)***. 


***Минимальная среда выполнения*** может существовать вне ОС и обычно используется в программировании встраиваемых систем. Такие среды предоставляют минимальный набор 
библиотечных функций, а название и тип точки входа, которая вызывается при запуске программы, зависит от реализации.


❗Необходимо следить за тем, ***чтобы данные, предоставленные пользователем, не стали первым аргументом функции printf()***, поскольку это чревато уязвимостью 
безопасности на основе отформатированного вывода. 


Программы, написанные на ***C***, можно считать ***строго соответствующими спецификации***, если они используют только те возможности языка и библиотеки, которые предусмотрены стандартом. Такие программы должны быть максимально переносимыми. Но в реальности из-за широкого разнообразия реализаций с разным поведением никакие программы на ***C*** не могут (и никогда не смогут) похвастаться строгим соблюдением  спецификации, и это, вероятно, нормально. Вместо этого можно создавать программы, ***частично соответствующие стандарту C***, которые могут зависеть от непереносимых возможностей языка и библиотеки.


***Виды проблем переносимости программ:***
- поведение, определяемое реализацией;
- неуточненное поведение;
- неопределенное поведение;
- поведение, зависящее от региональных параметров;
- распространенные расширения.


***Поведение, определяемое реализацией (implementation-defined behavior)***, не оговаривается стандартом C иможет иметь разные результаты в разных реализациях. При этом в рамках отдельно взятой реализации это поведение является предсказуемым и задокументированным. Примером может служить количество битов в байте.


***Неуточненное поведение (unspecified behavior)*** наблюдается, когда стандарт предусматривает несколько вариантов выполнения, но не уточняет, какой из них должен использоваться в том или ином случае. При каждом выполнении заданное выражение может иметь разные результаты или возвращать разные значения. Примером неуточненного поведения служит размещение параметров функции в памяти, которое может меняться при каждом вызове этой функции в рамках одной и той же программы. Старайтесь не писать код, зависящий от неуточненного поведения.

***Неопределенным (undefined)*** является поведение, которое не определено в стандарте C, т.е. «поведение при использовании непереносимых или ошибочных программных конструкций либо некорректных данных, к которому стандарт не предъявляет никаких требований». 
 
К неопределенному поведению относят ***переполнение знакового целого*** и ***разыменование некорректного указателя***. В стандарте неопределенное поведение описывается так:
- когда требование вида «должно» или «не должно» нарушается и, по всей видимости, выходит за рамки ограничения, поведение не определено;
- когда поведение явно описано как неопределенное;
- когда у поведения нет никакого явного определения.

***Комитет во главе стандарта C считает неопределенным поведение, которое:***
- дает разработчику реализации С повод не отлавливать программные ошибки, которые сложно диагностировать;
- избегает определения запутанных, граничных случаев, которые хорошо подходят только для какой-то одной стратегии реализации;
- устанавливает рамки возможного расширения языка, в которых разработчик реализации С может дополнить язык, предоставив определение официально неопределенного поведения.

***Компиляторы (реализации) могут делать следующее:***
- полностью игнорировать неопределенное поведение, возвращая непредсказуемые результаты;
- вести себя задокументированным образом, характерным для окружения (с выводом диагностического сообщения или без него);
- прекратить компиляцию или выполнение (с выводом диагностического 
сообщения)

На ***поведение, зависящее от региональных параметров (locale-specific behavior)***, влияют местные особенности, задокументированные в каждой отдельной реализации, включая национальные, культурные и языковые. Во многих системах широко применяются распространенные расширения, но их нельзя перенести на все реализации.



### Глава 2. Объекты, функции, типы и указатели
***Объект*** — это хранилище, в котором можно представлять значения. ***В стандарте C (ISO/IEC 9899:2018) объектом называется*** *"область хранилища данных в среде выполнения, содержимое которого 
может представлять значения"* с примечанием: *"при обращении к объекту можно считать, что он обладает определенным типом"*. Один из примеров объекта — переменная.

***Переменные*** имеют ***объявленный тип***, который говорит о том, какого рода объект представляет его значение. Например, объект типа ***int*** содержит целочисленное значение. Важность типа объясняется тем, что набор битов, представляющий объект одного типа, скорее всего, будет иметь другое значение, если его интерпретировать как объект другого типа. Например, в ***IEEE 754*** (стандарт IEEE для арифметических операций с плавающей запятой) *число 1 представлено как 0x3f800000* (IEEE 754–2008). Но если интерпретировать тот же набор битов *как целое число, то вместо 1 получится значение 1 065 353 216*.

***Функции** не являются объектами, но тоже имеют тип. Тип функции характеризуется как ее возвращаемым значением, так и числом и типами ее параметров.

В C есть ***указатели***, которые можно считать ***адресами — областями памяти***, в которых хранятся объекты или функции. Тип указателя, основанный на типе функции или объекта, называется ***ссылочным типом***. Указатель, имеющий ссылочный тип T, называют ***указателем на T***.

***Объекты и функции*** — это разные вещи, и потому ***объектные указатели отличаются от функциональных и их нельзя использовать как взаимозаменяемые***.

***У каждого объекта есть срок хранения***, который определяет его ***время жизни (lifetime)*** — период выполнения программы, на протяжении которого этот объект существует, где-то хранится, имеет постоянный адрес и сохраняет последнее присвоенное ему значение. К объектам нельзя 
обращаться вне данного периода

***Локальные переменные*** имеют ***автоматический срок хранения (storage duration)***, то есть они существуют, пока поток выполнения не покинет блок, в котором они определены.

***Параметры*** - это объекты, которые объявляются вместе с функцией и получают значения при входе в нее.

***Аргументы*** - это выражения, разделяемые запятыми, которые указываются в выражении вызова функции.

***В языке C передача аргументов при вызове происходит по значению***, т.е. когда вы предоставляете функции аргумент, его значение копируется в отдельную переменную, доступную для использования внутри этой функции. 

***Унарная операция * в выражениях внутри функции разыменовывает указатель на объект*** - берет значение по адресу.

***Передача аргументов по ссылке:*** сначала генерируются адреса объектов, которые передаются по значению, а затем они разыменовываются для доступа к исходным объектам.

Объекты, функции, макросы и другие идентификаторы языка C имеют ***область видимости***, которая определяет, где к ним можно обращаться. В языке C область видимости может быть следующих типов:
- ***на уровне файла:*** охватывает весь файл, в котором он находится, а также любые другие файлы, подключенные после его объявления (например, если объявление сделано за пределами 
какого-либо блока или списка параметров);
- ***на уровне блока:*** объявленный идентифиатор доступен только внутри этого блока (например, если объявление происходит внутри блока или списка параметров);
- ***на уровне прототипа:*** область видимости ограниченая ее объявлением (то есть прототипом) (например, если объявление происходит внутри списка параметров прототипа 
функции но не в ее теле);
- ***на уровне функции:*** охватывает определение идентификатора между открывающей ({) и закрывающей (}) скобками. Единственным видом идентификаторов, который имеет такую область видимости, являются ***метки*** — идентификаторы, завершающиеся двоеточием и определяющие оператор в функции, к которому может перейти управление

***Области видимости*** могут быть ***вложенными*** и находиться как ***внутри***, так и ***снаружи*** относительно других областей видимости. ***Внутренняя область имеет доступ к наружной, но не наоборот***. 

Если объявить один и тот же идентификатор как во внутренней, так и в наружной областях видимости, то ***внутренняя версия перекрывает наружную, имея более высокий приоритет***. В данном случае имя идентификатора будет ссылаться на объект во внутренней области видимости; объект из наружной области скрывается, и на него нельзя сослаться по имени. 

***Объекты имеют срок хранения***, который определяет их ***время жизни***. В целом сроки хранения бывают 4-х видов: 
- автоматические;
- статические; 
- потоковые;
- выделенные. 

***Объекты с автоматическим сроком хранения*** объявляются внутри блока или в качестве параметров функции. Их время жизни начинается в момент выполнения блока, в котором они объявлены, и заканчивается при его завершении. Если блок вызывается рекурсивно, то при каждом вызове создается новый объект с собственным сроком хранения.

> ***`Область видимости`*** и ***`время жизни`*** — совершенно разные понятия. Первое относится к идентификаторам, а второе — к объектам. ***Областью видимости идентификатора*** является участок кода, в котором к объекту, обозначенному этим идентификатором, можно получить доступ по его имени. ***Время жизни объекта*** — это период, на протяжении которого он существует.

Объекты, объявленные на уровне файла, имеют ***статический срок хранения***. Их время жизни охватывает весь период выполнения программы, а значения, которые в них хранятся, инициализируются еще до ее запуска. Можно объявить переменную со статическим сроком 
хранения внутри блочной области видимости, используя спецификатор класса хранения ***static***.

> При разработке ПО рекомендуется как можно сильнее ограничивать область видимости объектов.

Статические объекты должны инициализироваться с помощью константного значения, а не переменной:

```c
int *func(int i) 
{
  const int j = i; // правильно
  static int k = j; // ошибка
  return &k;
}
```

***К константным значениям*** относятся константы-литералы (например, `1`, `'a'` или `0xFF`), члены enum и результаты работы операций, таких как alignof или sizeof, но не объекты со спецификатором const.

***`Потоковый срок хранения`*** используется в конкурентном программировании. 

***`Динамический срок хранения`*** относится к динамически выделяемой памяти.




### Компиляция
Использовался компилятор ***gcc***


```
$ cc -o hello hello.c
```
ключи:
- ```-o``` — указать наименование для выходного исполняемого файла 


### Макросы
- ```EXIT_SUCCESS``` = 0
- ```EXIT_FAILURE``` = 1
- ```EOF``` = -1


### Функции
- ```puts(...)``` - вывод неотформатированной строки в stdout;
- ```printf(...)``` - вывод отформатированной строки в stdout;